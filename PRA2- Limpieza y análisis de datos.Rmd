---
title: "PRA2: Limpieza y análisis de datos"
author: "Joshua Prior Avila y Marcos Caballero"
date: "Mayo 2022"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes---
bibliography: citations.bib
link-citations: yes
csl: ieee.csl
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Se desea elaborar un proyecto analítico y usar las herramientas de integración, limpieza, validación y análisis de las mismas.
# Dataset "Red Wine Quality"
## ¿Por qué es importante? ¿Qué problema pretende responder?
Enlace al dataset de Kaggle [Red Wine Quality](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)

Se incluyen dos conjuntos de datos relacionados con muestras de vino tinto y blanco vinho verde, procedentes del norte de Portugal. El objetivo es modelar la calidad del vino a partir de pruebas fisicoquímicas.

Debido a cuestiones de privacidad y logística, sólo se dispone de variables fisicoquímicas (de entrada) y sensoriales (de salida) (por ejemplo, no hay datos sobre tipos de uva, marca de vino, precio de venta del vino, etc.). Estos conjuntos de datos pueden considerarse tareas de clasificación o de regresión. Las clases están ordenadas y no equilibradas (por ejemplo, hay muchos más vinos normales que excelentes o malos). Se podrían utilizar algoritmos de detección de valores atípicos para detectar los pocos vinos excelentes o malos. Además, no estamos seguros de que todas las variables de entrada sean relevantes. Así que podría ser interesante probar métodos de selección de características [@wine_quality].

## Descripción
Estos conjuntos de datos pueden considerarse tareas de clasificación o regresión. Las clases están ordenadas y no equilibradas (por ejemplo, hay más vinos normales que excelentes o malos). Los algoritmos de detección de valores atípicos podrían utilizarse para detectar los pocos vinos excelentes o pobres. o pobres. Además, no estamos seguros de que todas las variables de entrada sean relevantes. Así que podría ser interesante probar los métodos de selección de características. 

Nota: varios de los atributos pueden estar correlacionados, por lo que tiene sentido aplicar algún tipo de selección de características.

Variables de entrada (basadas en pruebas fisicoquímicas):
1. `fixed acidity`: acidez fija --> la mayoría de los ácidos que intervienen en el vino son fijos o no volátiles (no se evaporan fácilmente).
2. `volatile acidity`: acidez volátil --> la cantidad de ácido acético en el vino, que en niveles demasiado altos puede producir un sabor desagradable a vinagre.
3. `citric acid`: ácido cítrico --> en pequeñas cantidades, el ácido cítrico puede aportar "frescura" y sabor a los vinos.
4. `residual sugar`: azúcar residual --> la cantidad de azúcar que queda después de la fermentación; es raro encontrar vinos con menos de 1 gramo/litro.
5. `chlorides`: cloruros --> la cantidad de sal en el vino.
6. `free sulfur dioxide`: dióxido de azufre libre --> la forma libre de SO2 existe en equilibrio entre el SO2 molecular (como gas disuelto) y el ion bisulfito.
7. `total sulfur dioxide`: dióxido de azufre total --> la cantidad de formas libres y ligadas de S02; en bajas concentraciones, el SO2 es casi indetectable en el vino.
8. `density`: densidad --> la densidad se aproxima a la del agua en función del porcentaje de alcohol y del contenido de azúcar.
9. `pH`: pH --> describe el grado de acidez o base de un vino en una escala de 0 (muy ácido) a 14 (muy básico); la mayoría de los vinos se sitúan entre 3 y 4 grados.
10. `sulphates`: sulfatos --> un aditivo del vino que puede contribuir a los niveles de gas de dióxido de azufre (S02), que actúa como antimicrobiano
11. `alcohol`: el porcentaje de alcohol del vino.

Variable de salida (basada en datos sensoriales):
12. `quality`: calidad --> basada en datos sensoriales, puntuación entre 0 y 10.

# Pasos previos a la resolución del problema
Instalamos y cargamos las librerías necesarias
```{r echo=TRUE, message=FALSE, warning=FALSE}
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('corrplot')) install.packages('dplyr'); library('corrplot')
if (!require('randomForest')) install.packages('randomForest'); library('randomForest')
if (!require('ggthemes')) install.packages('ggthemes'); library('ggthemes')
if (!require('reshape2')) install.packages('reshape2'); library('reshape2')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
```
Cargamos el fichero de datos
```{r}
wines <- read.csv('winequality-red.csv',stringsAsFactors = FALSE)
```
# Integración y selección de los datos de interés a analizar
```{r}
wines$good.wine<-ifelse(wines$quality>6,1,0) # Variable que indique si un vino es bueno o malo
str(wines)
```
Vemo que tenemos 1599 registros y 13 variables que los caracterizan.
```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(wines)
```
Estas son las estadísticas básicas con skim.
Intentamos predecir la calidad del vino, por lo que nos interesan las dos últimas columnas/filas para saber cuál de las variables tiene una mayor relación con la calidad del vino. Como sugiere el mapa de calor, el alcohol tiene la mayor correlación con la calidad del vino. 
```{r message= FALSE, warning=FALSE}
ggplot(wines,aes(x=quality))+geom_bar(stat = "count",position = "dodge")+
  scale_x_continuous(breaks = seq(3,8,1))+
  ggtitle("Distribución de las puntuaciones de calidad")+
  theme_classic()
```
```{r message= FALSE, warning=FALSE}
ggplot(wines,aes(x=good.wine,fill=factor(good.wine)))+geom_bar(stat = "count",position = "dodge")+
  scale_x_continuous(breaks = seq(0,1,1))+
  ggtitle("Distribution of Good/Bad Red Wines")
  theme_classic()
```
El gráfico de arriba muestra lo que ya habíamos deducido anteriormente, que los buenos vinos fueron superados por los malos por un amplio margen. La mayoría de los vinos eran mediocres (con una calificación de 5 o 6), pero también pudimos ver que hay algunos vinos malos (3 o 4). La gran mayoría de los buenos vinos tiene una calificación de calidad de 7.
# Limpieza de los datos
## Valores vacíos
```{r}
colSums(is.na(wines))
colSums(wines=="")
colSums(wines == 0)
# sum(wines$citric.acid == 0)
```
## Valores extremos
```{r message= FALSE, warning=FALSE}
par(mfrow=c(2,2))
boxplot(wines$fixed.acidity)
boxplot(wines$volatile.acidity)
boxplot(wines$citric.acid)
boxplot(wines$residual.sugar)
boxplot(wines$chlorides)
boxplot(wines$free.sulfur.dioxide)
boxplot(wines$total.sulfur.dioxide)
boxplot(wines$density)
boxplot(wines$pH)
boxplot(wines$sulphates)
boxplot(wines$alcohol)
boxplot(wines$quality)
```
NOTA: DECIDIR GESTIÓN DE LOS OUTLIERS
# Análisis de los datos
Como sugiere el editor, clasificaremos los vinos estableciendo un límite arbitrario para nuestra variable dependiente (calidad del vino), por ejemplo, 7 o más se clasifica como "bueno/1" y el resto como "no bueno/0".
## Clasificación binaria con Random Forest
No utilizaremos ningún ajuste de hiperparámetros y nos quedaremos con el valor por defecto de la función randomForest.
```{r message= FALSE, warning=FALSE}
winesRF<-randomForest(factor(good.wine)~.-quality,wines,ntree=150)
winesRF
```
La precisión global de nuestro modelo es bastante buena, en torno al 92%. Sin embargo, podemos ver claramente que es mucho mejor para predecir los vinos malos que los buenos.
## Importancia de las variables
```{r message= FALSE, warning=FALSE}
# Obtener importancia
importance    <- importance(winesRF)

varImportance <- data.frame(Variables = row.names(importance), 
                            Importance = round(importance[ ,'MeanDecreaseGini'],2))

# Crear una variable de rango basada en la importancia
rankImportance <- varImportance %>%
  mutate(Rank = paste0('#',dense_rank(desc(Importance))))

# Visualizar la importancia relativa de las variables
ggplot(rankImportance, aes(x = reorder(Variables, Importance), 
                           y = Importance, fill = Importance)) +
  geom_bar(stat='identity') + 
  geom_text(aes(x = Variables, y = 0.5, label = Rank),
            hjust=0, vjust=0.55, size = 4, colour = 'red') +
  labs(x = 'Variables') +
  coord_flip() + 
  theme_classic()
```
Los resultados de nuestro modelo de bosque aleatorio muestran que el alcohol y el nivel de sulfatos son los factores que más discriminan la calidad del vino.
## Comprobación de la normalidad y homogeneidad de la varianza
Para la normalidad

ks.test() y shapiro.test()

Para la homogeneidad

levene-Test() y fligner.test()

## Aplicación de pruebas estadísticas

Cuando la normalidad y la homocedasticidad se cumplan (p-valores mayores al nivel de significancia), se podrán aplicar pruebas por contraste de hipótesis de tipo paramétrico, como la prueba t de Student. 

t.test()

En los casos en los que no se cumplan, se deberán aplicar pruebas no paramétricas como Wilcoxon (cuando se comparen datos dependientes) o Mann-Whitney (cuando los grupos de datos sean independientes)

fligner.test()

Regresión lineal:

lm()

Regresión logística:

glm()

Árboles de decisión:

C50::C5.0()

Clusters por kmeans:

kmeans(datos, 5)

# Representación de los datos

# Conclusiones
Como observaciones que hemos ido haciendo a lo largo de nuestro EDA, el dataset no dispone de datos sobre tipos de uva, marca de vino, precio de venta del vino, etc. que podrían ayudar a un análisis más detallado.
Las clases están ordenadas y no equilibradas (por ejemplo, hay muchos más vinos normales que excelentes o malos).
