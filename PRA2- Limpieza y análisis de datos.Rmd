---
title: "PRA2: Limpieza y análisis de datos"
author: "Joshua Prior Avila y Marcos Caballero"
date: "Mayo 2022"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes---
bibliography: citations.bib
link-citations: yes
csl: ieee.csl
---
RECURSO::: https://materials.campus.uoc.edu/daisy/Materials/PID_00265704/pdf/PID_00265704.pdf
NOTA::: HAY MUCHOS EJEMPLOS EN https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009/code?datasetId=4458&sortBy=voteCount&language=R
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Se desea elaborar un proyecto analítico y usar las herramientas de integración, limpieza, validación y análisis de las mismas.
****
# Dataset "Red Wine Quality"
****
## ¿Por qué es importante? ¿Qué problema pretende responder?
Enlace al dataset de Kaggle [Red Wine Quality](https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009)

Se incluyen dos conjuntos de datos relacionados con muestras de vino tinto y blanco vinho verde, procedentes del norte de Portugal. El objetivo es modelar la calidad del vino a partir de pruebas fisicoquímicas.

Debido a cuestiones de privacidad y logística, sólo se dispone de variables fisicoquímicas (de entrada) y sensoriales (de salida) (por ejemplo, no hay datos sobre tipos de uva, marca de vino, precio de venta del vino, etc.). Estos conjuntos de datos pueden considerarse tareas de clasificación o de regresión. Las clases están ordenadas y no equilibradas (por ejemplo, hay muchos más vinos normales que excelentes o malos). Se podrían utilizar algoritmos de detección de valores atípicos para detectar los pocos vinos excelentes o malos. Además, no estamos seguros de que todas las variables de entrada sean relevantes. Así que podría ser interesante probar métodos de selección de características [@wine_quality].

## Descripción
Estos conjuntos de datos pueden considerarse tareas de clasificación o regresión. Las clases están ordenadas y no equilibradas (por ejemplo, hay más vinos normales que excelentes o malos). Los algoritmos de detección de valores atípicos podrían utilizarse para detectar los pocos vinos excelentes o pobres. o pobres. Además, no estamos seguros de que todas las variables de entrada sean relevantes. Así que podría ser interesante probar los métodos de selección de características. 

Nota: varios de los atributos pueden estar correlacionados, por lo que tiene sentido aplicar algún tipo de selección de características.

Variables de entrada (basadas en pruebas fisicoquímicas):
1. `fixed acidity`: acidez fija --> la mayoría de los ácidos que intervienen en el vino son fijos o no volátiles (no se evaporan fácilmente).
2. `volatile acidity`: acidez volátil --> la cantidad de ácido acético en el vino, que en niveles demasiado altos puede producir un sabor desagradable a vinagre.
3. `citric acid`: ácido cítrico --> en pequeñas cantidades, el ácido cítrico puede aportar "frescura" y sabor a los vinos.
4. `residual sugar`: azúcar residual --> la cantidad de azúcar que queda después de la fermentación; es raro encontrar vinos con menos de 1 gramo/litro.
5. `chlorides`: cloruros --> la cantidad de sal en el vino.
6. `free sulfur dioxide`: dióxido de azufre libre --> la forma libre de SO2 existe en equilibrio entre el SO2 molecular (como gas disuelto) y el ion bisulfito.
7. `total sulfur dioxide`: dióxido de azufre total --> la cantidad de formas libres y ligadas de S02; en bajas concentraciones, el SO2 es casi indetectable en el vino.
8. `density`: densidad --> la densidad se aproxima a la del agua en función del porcentaje de alcohol y del contenido de azúcar.
9. `pH`: pH --> describe el grado de acidez o base de un vino en una escala de 0 (muy ácido) a 14 (muy básico); la mayoría de los vinos se sitúan entre 3 y 4 grados.
10. `sulphates`: sulfatos --> un aditivo del vino que puede contribuir a los niveles de gas de dióxido de azufre (S02), que actúa como antimicrobiano
11. `alcohol`: el porcentaje de alcohol del vino.

Variable de salida (basada en datos sensoriales):
12. `quality`: calidad --> basada en datos sensoriales, puntuación entre 0 y 10.

# Pasos previos a la resolución del problema
Instalamos y cargamos las librerías necesarias
```{r echo=TRUE, message=FALSE, warning=FALSE}
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('corrplot')) install.packages('dplyr'); library('corrplot')
```
Cargamos el fichero de datos
```{r}
wines <- read.csv('winequality-red.csv',stringsAsFactors = FALSE)
rows=dim(wines)[1]
```
# Integración y selección de los datos de interés a analizar
```{r}
str(wines)
```
Vemo que tenemos 1599 registros y 12 variables que los caracterizan.
```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(wines)
```
Estas son las estadísticas básicas. Veamos ahora las distribuciones:
```{r message= FALSE, warning=FALSE}
par(mfrow=c(2,2))
barplot(table(wines$fixed.acidity))
barplot(table(wines$volatile.acidity))
barplot(table(wines$citric.acid))
barplot(table(wines$residual.sugar))
barplot(table(wines$chlorides))
barplot(table(wines$free.sulfur.dioxide))
barplot(table(wines$total.sulfur.dioxide))
barplot(table(wines$density))
barplot(table(wines$pH))
barplot(table(wines$sulphates))
barplot(table(wines$alcohol))
barplot(table(wines$quality))
```
Nos proponemos analizar las relaciones entre las diferentes variables del juego de datos para ver si se relacionan y cómo. Visualizamos la relación entre las variables "gender" y "survived":
```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=totalData[1:filas,],aes(x=gender,fill=survived))+geom_bar()+ggtitle("Relación entre las variables gender y survived")
```
Obtenemos ahora una matriz de porcentajes de frecuencia.
Vemos, por ejemplo que la probabilidad de sobrevivir si se embarcó en "C" es de un 56.45%

```{r echo=TRUE, message=FALSE, warning=FALSE}
t<-table(totalData[1:filas,]$embarked,totalData[1:filas,]$survived)
for (i in 1:dim(t)[1]){
    t[i,]<-t[i,]/sum(t[i,])*100
}
t
```

Veamos ahora como en un mismo gráfico de frecuencias podemos trabajar con 3 variables: Embarked, Survived y class.

Mostramos el gráfico de embarcados por Pclass:

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data = totalData[1:filas,],aes(x=embarked,fill=survived))+geom_bar(position="fill")+facet_wrap(~class)+ggtitle("Pasajeros por clase, puerto de origen y relación con survived")
```
# Limpieza de los datos
## Valores vacíos
```{r}
colSums(is.na(wines))
colSums(wines=="")
colSums(wines == 0)
# sum(wines$citric.acid == 0)
```
## Valores extremos
```{r message= FALSE, warning=FALSE}
par(mfrow=c(2,2))
boxplot(wines$fixed.acidity)
boxplot(wines$volatile.acidity)
boxplot(wines$citric.acid)
boxplot(wines$residual.sugar)
boxplot(wines$chlorides)
boxplot(wines$free.sulfur.dioxide)
boxplot(wines$total.sulfur.dioxide)
boxplot(wines$density)
boxplot(wines$pH)
boxplot(wines$sulphates)
boxplot(wines$alcohol)
boxplot(wines$quality)
```
NOTA: DECIDIR GESTIÓN DE LOS OUTLIERS
# Análisis de los datos
¿Comparar entre los de calidad alta, media y baja? ¿Atributos más determinantes en la calidad? ¿Probar a categorizar por clústeres?
```{r message= FALSE, warning=FALSE}
sum(datos$quality == 3 | datos$quality == 4)
sum(datos$quality == 5 | datos$quality == 6)
sum(datos$quality == 7 | datos$quality == 8)
```
Discretizamos la variable de calidad
```{r}
wines["segmento_calidad"] <- cut(wines$quality, breaks = c(0,5,7,9,10), labels = c("Baja", "Media", "Alta", "Excelente"))
head(wines)
```
Vemos cómo se agrupan los vinos por segmento de calidad
```{r}
plot(wines$quality,main="Número de vinos por segmento de calidad",xlab="Calidad", ylab="Cantidad",col = "ivory")
```
Como alternativa a la discretización realizada discretizaremos ahora edad con kmeans.

```{r}
# https://cran.r-project.org/web/packages/arules/index.html
if (!require('arules')) install.packages('arules'); library('arules')
set.seed(2)
table(discretize(totalData$age, "cluster" ))
hist(totalData$age, main="Número de pasajeros por grupos de edad con kmeans",xlab="Edad", ylab="Cantidad",col = "ivory")
abline(v=discretize(totalData$age, method="cluster", onlycuts=TRUE),col="red")
```

Podemos observar que sin pasar ningún argumento y que el algoritmo  escoja el conjunto de particiones se muestran tres clústeres que agrupan las edades en las franjas mencionadas.
Podemos asignar el propio clúster como una variable más al dataset para trabajar después.


```{r}
totalData$edad_KM <- (discretize(totalData$age, "cluster" ))
head(totalData)
```

## Comprobación de la normalidad y homogeneidad de la varianza
Para la normalidad

ks.test() y shapiro.test()

Para la homogeneidad

levene-Test() y fligner.test()

## Aplicación de pruebas estadísticas
```{r message= FALSE, warning=FALSE}
corrplot(cor(datos),method='color',tl.col="black")
```

Cuando la normalidad y la homocedasticidad se cumplan (p-valores mayores al nivel de significancia), se podrán aplicar pruebas por contraste de hipótesis de tipo paramétrico, como la prueba t de Student. 

t.test()

En los casos en los que no se cumplan, se deberán aplicar pruebas no paramétricas como Wilcoxon (cuando se comparen datos dependientes) o Mann-Whitney (cuando los grupos de datos sean independientes)

fligner.test()

Regresión lineal:

lm()

Regresión logística:

glm()

Árboles de decisión:

C50::C5.0()

Clusters por kmeans:

kmeans(datos, 5)

# Representación de los datos

# Conclusiones
